#!/usr/bin/env python3

import unittest
import os
from scipy.io import netcdf
import numpy as np
import logging
from qsc.qsc import Qsc

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ToVmecTests(unittest.TestCase):

    def test_1(self):
        """
        Compare the RBC/ZBS values to those generated by the fortran version,
        for the 3 O(r^1) examples in LandremanSenguptaPlunk (and eventually the r^2 examples).
        Some of those examples in the fortran repo use finite_r_option='linear'
        instead of nonlinear, so you'd want to run them with finite_r_option='nonlinear'
        to generate analogous RBC/ZBS data.
        """

    def test_2(self):
        """
        We can build vmec in the CI, and run it on input files generated by pyQSC,
        to make sure that vmec can actually read the generated input files.
        Then we can have some asserts that vmec's iota and bmnc[0,0] match
        the predicted values. Installing vmec from the hiddenSymmetries repo
        may be faster than installing vmec from stellopt, because the stellopt
        version has tons of extra stuff in libstell. We wouldn't need to build
        the python wrapper for vmec, and could just call the xvmec standalone executable.
        """

    def test_3(self):
        """
        Transforming with to_Fourier and then un-transforming should give the identity,
        for both even and odd ntheta and phi, and for lasym True or False.
        """

if __name__ == "__main__":
    unittest.main()