#!/usr/bin/env python3

import unittest
import os
from scipy.io import netcdf
import numpy as np
import logging
from qsc.qsc import Qsc

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def compare_to_fortran(name, filename):
    """
    Compare output from this python code to the fortran code, for one
    of the example configurations from the papers.
    """
    # Add the directory of this file to the specified filename:
    abs_filename = os.path.join(os.path.dirname(__file__), filename)
    f = netcdf.netcdf_file(abs_filename, 'r')
    nphi = f.variables['N_phi'][()]
    r = f.variables['r'][()]
    mpol = f.variables['mpol'][()]
    ntor = f.variables['ntor'][()]

    py = Qsc.from_paper(name, nphi=nphi)
    py.to_vmec(str("input."+name).replace(" ",""), r=r,params={'mpol': mpol, 'ntor': ntor})
    logger.info('Comparing to fortran file ' + abs_filename)

    def compare_field(fortran_name, py_field, rtol=1e-9, atol=1e-9):
        fortran_field = f.variables[fortran_name][()]
        logger.info('max difference in {}: {}'.format(fortran_name, np.max(np.abs(fortran_field - py_field))))
        np.testing.assert_allclose(fortran_field, py_field, rtol=rtol, atol=atol)

    compare_field('RBC', py.RBC)
    compare_field('RBS', py.RBS)
    compare_field('ZBC', py.ZBC)
    compare_field('ZBS', py.ZBS)
    f.close()

class ToVmecTests(unittest.TestCase):

    def test_1(self):
        """
        Compare the RBC/ZBS values to those generated by the fortran version,
        for the 3 O(r^1) examples in LandremanSenguptaPlunk.
        """
        compare_to_fortran("r1 section 5.1", "quasisymmetry_out.LandremanSenguptaPlunk_section5.1_order_r1_finite_r_nonlinear.reference.nc")
        compare_to_fortran("r1 section 5.2", "quasisymmetry_out.LandremanSenguptaPlunk_section5.2_order_r1_finite_r_nonlinear.reference.nc")
        compare_to_fortran("r1 section 5.3", "quasisymmetry_out.LandremanSenguptaPlunk_section5.3_order_r1_finite_r_nonlinear.reference.nc")

    def test_2(self):
        """
        We can build vmec in the CI, and run it on input files generated by pyQSC,
        to make sure that vmec can actually read the generated input files.
        Then we can have some asserts that vmec's iota and bmnc[0,0] match
        the predicted values. Installing vmec from the hiddenSymmetries repo
        may be faster than installing vmec from stellopt, because the stellopt
        version has tons of extra stuff in libstell. We wouldn't need to build
        the python wrapper for vmec, and could just call the xvmec standalone executable.
        """

    def test_3(self):
        """
        Transforming with to_Fourier and then un-transforming should give the identity,
        for both even and odd ntheta and phi, and for lasym True or False.
        """

if __name__ == "__main__":
    unittest.main()