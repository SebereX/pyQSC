"""
This module contains the routines to output a
near-axis boundary to a VMEC input file
"""
from qsc.Frenet_to_cylindrical import Frenet_to_cylindrical
import numpy as np
from .util import mu0

def to_Fourier(R_2D, Z_2D, nfp, ntheta, mpol1d, ntord, lasym):
    N_phi_conversion = np.array(R_2D).shape[1]
    theta = np.linspace(0,2*np.pi,ntheta,endpoint=False)
    phi_conversion = np.linspace(0,2*np.pi/nfp,N_phi_conversion,endpoint=False)
    ntheta = np.array(theta).shape[0]
    mpol = int(min(ntheta          / 2, mpol1d))
    ntor = int(min(N_phi_conversion / 2, ntord))
    RBC = np.zeros((int(2*ntor+1),int(mpol+1)))
    RBS = np.zeros((int(2*ntor+1),int(mpol+1)))
    ZBC = np.zeros((int(2*ntor+1),int(mpol+1)))
    ZBS = np.zeros((int(2*ntor+1),int(mpol+1)))
    factor = 2 / (ntheta * N_phi_conversion)
    for j_phi in range(N_phi_conversion):
        for j_theta in range(ntheta):
            for m in range(mpol+1):
                nmin = -ntor
                if m==0: nmin = 1
                for n in range(nmin, ntor+1):
                    angle = m * theta[j_theta] - n * nfp * phi_conversion[j_phi]
                    sinangle = np.sin(angle)
                    cosangle = np.cos(angle)
                    factor2 = factor
                    # The next 2 lines ensure inverse Fourier transform(Fourier transform) = identity
                    if np.mod(ntheta,2) == 0 and m  == (ntheta/2): factor2 = factor2 / 2
                    if np.mod(N_phi_conversion,2) == 0 and abs(n) == (N_phi_conversion/2): factor2 = factor2 / 2
                    RBC[n,m] = RBC[n,m] + R_2D[j_theta, j_phi] * cosangle * factor2
                    RBS[n,m] = RBS[n,m] + R_2D[j_theta, j_phi] * sinangle * factor2
                    ZBC[n,m] = ZBC[n,m] + Z_2D[j_theta, j_phi] * cosangle * factor2
                    ZBS[n,m] = ZBS[n,m] + Z_2D[j_theta, j_phi] * sinangle * factor2
    RBC[0,0] = np.sum(R_2D) / (ntheta * N_phi_conversion)
    ZBC[0,0] = np.sum(Z_2D) / (ntheta * N_phi_conversion)

    if lasym == False:
        RBS = 0
        ZBC = 0

    return RBC, RBS, ZBC, ZBS

def to_vmec(self, filename, r=0.1, input_template=None, ntheta=20):
    """
    Output a near-axis boundary to a VMEC input file
    """
    if input_template==None:
        delt=0.9
        nstep=200
        tcon0=2.
        mpol=10
        ntorMax=14
        ns_array=[16,49,101]
        ftol_array=[1e-13,1e-12,1e-11]
        niter_array=[1000,1000,1500]

    phiedge = np.pi * r * r * self.spsi * self.Bbar

    # Set pressure Profile
    temp = - self.p2 * r * r
    am = [temp,-temp]
    pmass_type='power_series'
    pres_scale=1

    # Set current profile:
    ncurr = 1
    pcurr_type = 'power_series'
    ac = [1]
    curtor = 2 * np.pi / mu0 * self.I2 * r * r

    # The output is not stellarator-symmetric if (1) R0s is nonzero, (2) Z0c is nonzero, or (3) sigma_initial is nonzero
    lasym = np.max(np.abs(self.rs))>0 or np.max(np.abs(self.zc))>0 or np.abs(self.sigma0)>0

    # We should be able to resolve (N_phi-1)/2 modes (note integer division!), but in case N_phi is very large, don't attempt more than the vmec arrays can handle.
    ntord = 100 # maximum number of mode numbers VMEC can handle
    ntor = int(min((self.nphi - 1) / 2, ntord))
    mpold = 101
    mpol1d = mpold - 1

    # Get surface shape at fixed off-axis toroidal angle phi
    R_2D, Z_2D, phi0_2D = self.Frenet_to_cylindrical(r, ntheta)
    
    # Fourier transform the result.
    # This is not a rate-limiting step, so for clarity of code, we don't bother with an FFT.
    RBC, RBS, ZBC, ZBS = to_Fourier(R_2D, Z_2D, self.nfp, ntheta, mpol1d, ntord, lasym)

    # Write to VMEC file
    File_object = open(filename,"w+")
    File_object.write("! This &INDATA namelist was generated by pyQSC\n")
    if input_template!=None:    File_object.write("! Based on template file ",input_template+'\n')
    File_object.write("! r ="+str(r)+'\n')
    File_object.write('!----- Runtime Parameters -----\n')
    File_object.write('&INDATA\n')
    File_object.write('  DELT = '+str(delt)+'\n')
    File_object.write('  NSTEP = '+str(nstep)+'\n')
    File_object.write('  TCON0 = '+str(tcon0)+'\n')
    File_object.write('  NS_ARRAY = '+str(ns_array)[1:-1]+'\n')
    File_object.write('  FTOL_ARRAY = '+str(ftol_array)[1:-1]+'\n')
    File_object.write('  NITER_ARRAY = '+str(niter_array)[1:-1]+'\n')
    File_object.write('!----- Grid Parameters -----\n')
    File_object.write('  LASYM = '+str(lasym)+'\n')
    File_object.write('  NFP = '+str(self.nfp)+'\n')
    File_object.write('  MPOL = '+str(mpol)+'\n')
    File_object.write('  NTOR = '+str(min(ntor,ntorMax))+'\n')
    File_object.write('  PHIEDGE = '+str(phiedge)+'\n')
    File_object.write('!----- Pressure Parameters -----\n')
    File_object.write('  PRES_SCALE = '+str(pres_scale)+'\n')
    File_object.write("  PMASS_TYPE = '"+pmass_type+"'\n")
    File_object.write('  AM = '+str(am)[1:-1]+'\n')
    File_object.write('!----- Current/Iota Parameters -----\n')
    File_object.write('  CURTOR = '+str(curtor)+'\n')
    File_object.write('  NCURR = '+str(ncurr)+'\n')
    File_object.write("  PCURR_TYPE = '"+pcurr_type+"'\n")
    File_object.write('  AC = '+str(ac)[1:-1]+'\n')
    File_object.write('!----- Axis Parameters -----\n')
    # To convert sin(...) modes to vmec, we introduce a minus sign. This is because in vmec,
    # R and Z ~ sin(m theta - n phi), which for m=0 is sin(-n phi) = -sin(n phi).
    File_object.write('  RAXIS_CC = '+str(self.rc)[1:-1]+'\n')
    if lasym:
        File_object.write('  RAXIS_CS = '+str(-self.rs)[1:-1]+'\n')
        File_object.write('  ZAXIS_CC = '+str(self.zc)[1:-1]+'\n')
    File_object.write('  ZAXIS_CS = '+str(-self.zs)[1:-1]+'\n')
    File_object.write('!----- Boundary Parameters -----\n')
    for m in range(mpol):
        for n in range(-ntor,ntor+1):
            if RBC[n,m]!=0 or ZBS[n,m]!=0:
                File_object.write(    '  RBC('+f"{n:03d}"+','+f"{m:03d}"+') = '+f"{RBC[n,m]:+.16e}"+',    ZBS('+f"{n:03d}"+','+f"{m:03d}"+') = '+f"{ZBS[n,m]:+.16e}"+'\n')
                if lasym == True:
                    File_object.write('  RBS('+f"{n:03d}"+','+f"{m:03d}"+') = '+f"{RBS[n,m]:+.16e}"+',    ZBC('+f"{n:03d}"+','+f"{m:03d}"+') = '+f"{ZBC[n,m]:+.16e}"+'\n')
    File_object.write('/\n')
    File_object.close()

    self.RBC = RBC
    self.RBS = RBS
    self.ZBC = ZBC
    self.ZBS = ZBS